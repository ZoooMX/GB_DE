"""
1. Написать функцию num_translate(), переводящую числительные от 0 до 10 c
английского на русский язык. Например:

#>>> num_translate("one")
"один"
#>>> num_translate("eight")
"восемь"

Если перевод сделать невозможно, вернуть None. Подумайте, как и где лучше
хранить информацию, необходимую для перевода: какой тип данных выбрать, в
теле функции или снаружи.
"""

def num_translate(word):
    """Выводит перевод числительных от 0 до 10 c
       английского на русский язык"""
    word = word.lower()
    dict_num = {'one': 'один',
                'two': 'два',
                'three': 'три',
                'four': 'четыре',
                'five': 'пять',
                'six': 'шесть',
                'seven': 'семь',
                'eight': 'восемь',
                'nine': 'девять',
                'ten': 'десять'}
    print(dict_num.get(word))

# num_translate(input('Enter a number up to 10 in words for translation: ')) # вызов функции



"""
2. * (вместо задачи 1) Доработать предыдущую функцию в num_translate_adv():
реализовать корректную работу с числительными, начинающимися с заглавной буквы
— результат тоже должен быть с заглавной.
Например:

>>> num_translate_adv("One")
"Один"
>>> num_translate_adv("two")
"два"
"""

def num_translate_adv(word):
    """Выводит перевод числительных от 0 до 10 c
       английского на русский язык учитывая регистр букв"""
    dict_num = {'one': 'один',
                'two': 'два',
                'three': 'три',
                'four': 'четыре',
                'five': 'пять',
                'six': 'шесть',
                'seven': 'семь',
                'eight': 'восемь',
                'nine': 'девять',
                'ten': 'десять',


    }
    w = chr(ord(word.title()[0]))
    if chr(ord(word[0])) == w:
        word_lower = word.lower()
        word_t = dict_num.get(word_lower)
        print(word_t.title())
    else:
        print(dict_num.get(word))

# num_translate_adv(input('Enter a number up to 10 in words for translation: ')) # вызов функции



"""
3. Написать функцию thesaurus(), принимающую в качестве аргументов имена
сотрудников и возвращающую словарь, в котором ключи — первые буквы имён,
а значения — списки, содержащие имена, начинающиеся с соответствующей буквы.
Например:

>>>  thesaurus("Иван", "Мария", "Петр", "Илья")
{
    "И": ["Иван", "Илья"],
    "М": ["Мария"], "П": ["Петр"]
}
Подумайте: полезен ли будет вам оператор распаковки? Как поступить, если
потребуется сортировка по ключам? Можно ли использовать словарь в этом случае?
"""

dict_name = {}
i = ['Иван', 'Владимир', 'Петр', 'Илья', 'Марина', 'Алексей',
     'Александра', 'Екатерина', 'Владислав', 'Вениамин']

def thesaurus(names):
    """Возвращает в словарь значения из полученного списка
       сортируя ключ-значение по первой букве"""
    names.sort()  # сортировка
    for name in names:
        w_k = chr(ord(name[0]))
        name_v = []
        for n in names:
            if chr(ord(n[0])) == w_k:
                 name_v.append(n)
        dict_name[w_k] = name_v

# thesaurus(i) # вызов функции
# print(dict_name)



"""
============================= НЕ РЕШЕНА, РАБОТАЮ НАД НЕЙ ========================
4. * (вместо задачи 3) Написать функцию thesaurus_adv(), принимающую в качестве
аргументов строки в формате «Имя Фамилия» и возвращающую словарь, в котором ключи
— первые буквы фамилий, а значения — словари, реализованные по схеме предыдущего
задания и содержащие записи, в которых фамилия начинается с соответствующей буквы.
Например:

>>> thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева")
{
    "А": {
        "П": ["Петр Алексеев"]
    },
    "И": {
        "И": ["Илья Иванов"]
    },
    "С": {
        "И": ["Иван Сергеев", "Инна Серова"],
        "А": ["Анна Савельева"]
    }
}
Как поступить, если потребуется сортировка по ключам?
"""



"""
5. Реализовать функцию get_jokes(), возвращающую n шуток, сформированных из трех
случайных слов, взятых из трёх списков (по одному из каждого):

nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]
        Например:
>>> get_jokes(2)
["лес завтра зеленый", "город вчера веселый"]
Документировать код функции.

Сможете ли вы добавить еще один аргумент — флаг, разрешающий или запрещающий
повторы слов в шутках (когда каждое слово можно использовать только в одной шутке)?
Сможете ли вы сделать аргументы именованными?
"""

def get_jokes(i):
    """Выводит 2 сгенерированные шутки внутри 1 списка, при
    аргументе "i" включается исключение повторения слов в шутках"""
    import random
    nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
    adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
    adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]

    active = True
    while active:
        joke = []
        noun_1 = nouns[random.randint(0, 4)]
        adverb_1 = adverbs[random.randint(0, 4)]
        adjective_1 = adjectives[random.randint(0, 4)]
        noun_2 = nouns[random.randint(0, 4)]
        adverb_2 = adverbs[random.randint(0, 4)]
        adjective_2 = adjectives[random.randint(0, 4)]
        if i == 'i':
            if noun_1 != noun_2 and adverb_1 != adverb_2 and adjective_1 != adjective_2:
                joke.extend([noun_1 + ' ' + adverb_1 + ' ' + adjective_1])
                joke.extend([noun_2 + ' ' + adverb_2 + ' ' + adjective_2])
                print('Исключения повторения слов ВКЛЮЧЕНО!')
                print(joke)
                active = False
            else:
                active = True
        else:
            print('Исключения повторения слов ВЫКЛЮЧЕНО!')
            joke.extend([noun_1 + ' ' + adverb_1 + ' ' + adjective_1])
            joke.extend([noun_2 + ' ' + adverb_2 + ' ' + adjective_2])
            print(joke)
            active = False

# get_jokes('i') # вызов функции
